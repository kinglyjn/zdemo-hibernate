
============================================================================================
基本介绍：
	1. session接口是hibernate向应用程序提供的操作数据库的最主要的接口，它提供了基本的
		保存、更新、删除、加载 java对象的方法。
		
	2. session具有一个缓存，位于缓存中的对象称之为持久化对象，它和数据库中的相关记录对应。
	   session能够在某些时间点按照缓存中对象的变化来执行相关的sql语句，来同步更新数据库，这一过程称之为刷新缓存（flush）。
	   
	3. 站在持久化的角度，hibernate把对象分为四种状态：
	   持久化状态、临时状态、游离状态、删除状态。
	   session的特定方法能使对象从一个状态转化到另一个状态。
   
    
============================================================================================
session缓存：
 	 测试session缓存
	 测试结果显示：该方法只向数据库发送一条sql查询语句
	 session缓存：在session的接口实现中，包含一系列的java集合，这些java集合构成了session缓存。
 				 只要session的生命周期没有结束，且session没有清理缓存，则存放在它缓存中的对象
 				 也不会结束生命周期。
		   					
	   					session缓存
		  					|
		 引用变量news---->news对象---->引用变量news2
		 
		 
		 |session缓存---------a.flush()------------>数据库中的
		 |中的news对象<---------b.refresh()----------news记录
		 |  c.clear()
		 
		 a.//当调用session.flush()方法时，session会检查session缓存中的对象的状态是否和数据库中的一致，不一
		   致的情况下，session会发送sql语句到数据库，使数据库对应记录的状态和session缓存中对象的状态保持一致。
		   [注1]
		   tx.commit()方法会先进行session.flush()，此时可能会向数据库发送sql更新语句以保持session缓
		   存与数据库记录的一致性，然后执行doCommit提交事务，提交事务之后，数据库的相关记录才会真正改变。
		   [注2]
		   当执行HQL或QBC查询，也会先进行session.flush()操作，以得到数据表的最新的记录。
		   [注3]
		   若记录的id是由底层数据库使用自增的方式生成的，则在调用session.save()方法后，就会立即发送insert语句，
		   因为save方法执行后必须要保证对象的id是存在并且有效的（只有向数据库发送insert语句才知道当前的id是几）
		   [注4]
		   session.flush()只可能会向数据库发送sql更新语句，但不会提交事务！  
		 
		 b.//在此处打断点，当代码执行到这一句时，更改数据库对应记录
		   会强制发送select语句，以使session缓存中对象的状态和数据库表中对应的记录保持一致
			（这里执行结果并未像预测的那样打印出最新更改的那条记录，原因是mysql默认的事务隔离级别是REPEATABLE_READ）
			 设置数据库事务隔离级别 1READ_UNCOMMITED|2READ_COMMITED|4REPEATABLE_READ|8SERIALIZEABLE
			 <property name="connection.isolation">2</property>
		
		 c.//清理session缓存，当执行session.clear()之后，session缓存中的数据会被清空！
		 
	
	
			 
============================================================================================
	持久化对象的状态					oid		数据库中是否有对应的记录		是否处在session缓存中		备注
	--------------------------------------------------------------------------------------------------------------------------------------------------
	Transient（临时状态，没入职）		null			否						否				无		
	Persist	 （持久化状态，入职了）		xxxx			是						是				session.flush执行时，会根据持久化对象属性的变化，来同步更新数据库
	Detached （游离状态，请假了）		xxxx			是						否				一般情况下，游离对象是由持久化对象转变而来的，因此数据库中还存在与它对应的记录
	Removed	 （删除状态，离职了）	 	xxxx			否						否				一般情况下应用程序不该再使用被删除的对象
	--------------------------------------------------------------------------------------------------------------------------------------------------
		 	
	
	session的核心方法：
		1.save 
			1) 使一个临时对象变为持久化对象
			2) 为对象分配id
			3) 在flush缓存时会发送一条insert语句
			4) 在save之前设置的id是无效的，在方法之后设置id会抛出异常
			
		2.persist和save方法的区别
			1) 如果在persist方法之前对象已经有id了，则执行persist方法会抛出异常
			
		3.get和load方法的区别
			1) 执行get方法会立即加载对象，返回的是真正的原对象；而执行load方法，只有使用到该对象时，才会执行查询操作，返回一个javassist代理
			2) 如果数据库表中没有对应的记录，且session没有被关闭，get返回null，而load[在使用对象时]会抛出一个异常
			3) load方法可能会抛出懒加载异常（LazyInitializationException），因为在需要初始化代理对象之前已经关闭了session，因而无法初始化代理对象而抛出懒加载异常
		
		4.update
			1) 若更新一个持久化对象，不需要显式地调用update方法，因为在调用tx.commit方法时，会先执行session.flush方法
			2) 更新一个游离对象，需要显式地调用session.update()
			3）对于[游离对象]，无论要更新的游离对象和数据表记录是否一致，都会向数据库发送update语句。
			   那么如何能让update方法不再盲目地触发update语句呢？
			   key：在*.hbm.xml文件的class节点上设置select-before-update=true（默认为false）
			   	    但通常不设置该属性（除非是需要跟触发器协同工作情况下），因为设置该属性在需要更新的情况下得多发一条查询语句，效率上反而会降低。
			4) 若数据表中没有对应的记录（不是游离对象），但还是调用了update方法，这时候update会抛出异常
			5) 当update方法更新一个游离对象时，如果在session缓存中已经存在了一个相同oid的持久化对象，则会抛出异常，因为session缓存中不能存在两个相同oid的对象  	    
		
		5.saveOrUpdate
			1) 当对象是临时对象时执行save方法，当对象是游离状态时执行update方法，通常情况下根据对象的oid是否为null即可判断
			2) 若oid不为null，但数据表中还没有对应的记录，会抛出一个异常
			3) oid的值等于*.hbm.xml中id节点的unsaved-value属性值的对象，也被认为是一个游离对象
			  
		6.delete
			1) 既可以删除游离对象，也可以删除持久化对象（只要oid和数据表中一条记录就可以删），删除的对象若在数据表中没有对应的记录，则抛出异常
			2) 真正向数据库发送delete语句是在session.flush方法执行的时候！
			3) delete方法执行之后，对象变为了删除状态，这时候应用程序不该再使用被删除的对象（如果对删除状态的对象save、update等操作可能会抛异常），
			   可以通过设置*.cfg.xml文件的hibernate.use_identifier_rollback=true（默认为false），设置完之后，delete方法将改变它的运行行为，
			   即delete方法会把持久化对象或游离对象的oid设置为null，使他们立即变为临时对象。
		
		7.evict
			1) 将持久化对象从session缓存中移除
			 	
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
				 	
		 	 
		 	 
			 